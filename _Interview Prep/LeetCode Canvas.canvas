{
	"nodes":[
		{"id":"94b330dcf24cb4cc","type":"text","text":"## Constant Time O(1)\n\n```js\n// Linear Time O(1)\n\nfunction accessElement(array, index) {\n\n\treturn array[index];\n\n}\n```","x":-2160,"y":-940,"width":440,"height":320},
		{"id":"29072537a1985352","type":"text","text":"## Logarithmic Time O(log n)\n\n```js\n// O(log n) - Logarithmic Time\n\nfunction binarySearch(array, target) {\n\nlet left = 0;\n\nlet right = array.length - 1;\n\nwhile (left <= right) {\n\n\tlet mid = Math.floor((left + right) / 2);\n\n\tif (array[mid] === target) {\n\t\n\t\treturn mid; // Found the target\n\t\n\t} else if (array[mid] < target) {\n\t\n\t\tleft = mid + 1; \n\t\t// Continue searching in the right half\n\t\n\t} else {\n\t\n\t\tright = mid - 1; \n\t\t// Continue searching in the left half\n\t\n\t}\n\n }\n\n\treturn -1; // Target not found\n\n}\n\n```","x":-2320,"y":-560,"width":600,"height":800},
		{"id":"e5899847cdd8566b","type":"text","text":"## Linearithmic Time O(n log n)\n```js\n// O(n log n) - Linearithmic Time\n\nfunction mergeSort(array) {\n\n\tif (array.length <= 1) {\n\t\n\t\treturn array;\n\t\n\t}\n\t\n\tconst mid = Math.floor(array.length / 2);\n\t\n\tconst left = mergeSort(array.slice(0, mid));\n\t\n\tconst right = mergeSort(array.slice(mid));\n\t\n\treturn merge(left, right);\n\n}\n\nfunction merge(left, right) {\n\n\tlet result = [];\n\t\n\tlet leftIndex = 0;\n\t\n\tlet rightIndex = 0;\n\t\n\twhile (leftIndex < left.length && rightIndex < right.length) {\n\t\n\t\tif (left[leftIndex] < right[rightIndex]) {\n\t\t\n\t\t\tresult.push(left[leftIndex]);\n\t\t\n\t\t\tleftIndex++;\n\t\t\n\t\t} else {\n\t\t\n\t\t\tresult.push(right[rightIndex]);\n\t\t\n\t\t\trightIndex++;\n\t\t\n\t\t}\n\t\n\t}\n\n\treturn result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n\n}\n```","x":-1122,"y":-577,"width":680,"height":1110},
		{"id":"787dace1ed352460","type":"text","text":"## Quadratic Time O(n^2)\n```js\n// O(n^2) - Quadratic Time\nfunction bubbleSort(array) {\n\t\n\tconst n = array.length;\n\n\tfor (let i = 0; i < n - 1; i++) {\n\t\n\t\tfor (let j = 0; j < n - i - 1; j++) {\n\t\t\n\t\t\tif (array[j] > array[j + 1]) {\n\t\t\t\n\t\t\t\t// Swap array[j] and array[j+1]\n\t\t\t\t\n\t\t\t\tlet temp = array[j];\n\t\t\t\t\n\t\t\t\tarray[j] = array[j + 1];\n\t\t\t\t\n\t\t\t\tarray[j + 1] = temp;\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn array;\n\n}\n\n\n\n\n\n\n\n\n```","x":-380,"y":-577,"width":537,"height":660},
		{"id":"13807d0f7b42aab3","type":"text","text":"## Linear Time O(n)\n```js\n// O(n) - Linear Time\n\nfunction findMax(array) {\n\n\tlet max = array[0];\n\t\n\tfor (let i = 1; i < array.length; i++) {\n\t\n\t\tif (array[i] > max) {\n\t\t\n\t\t\tmax = array[i];\n\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn max;\n\n}\n\n```","x":-1680,"y":-577,"width":516,"height":510},
		{"id":"6048d7c76ce951fa","type":"text","text":"##  [Leetcode Problem 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\n\n\nBoth approaches have the same implementation because the iterative approach already achieves O(log n) time complexity. The optimized approach using binary search is essentially the same as the iterative approach.\n```js\n\nfunction findMin(nums) {\n\n\tlet left = 0;\n\t\n\tlet right = nums.length - 1;\n\t\n\twhile (left < right) {\n\t\n\t\tconst mid = Math.floor((left + right) / 2);\n\t\n\t\tif (nums[mid] < nums[right]) {\n\t\t\n\t\t\tright = mid;\n\t\t\n\t\t} else {\n\t\t\n\t\t\tleft = mid + 1;\n\t\t\n\t\t}\n\t\n\t}\n\n\treturn nums[left];\n\n}\n\n  \n\n// Example usage:\n\nconst rotatedArray1 = [4, 5, 6, 7, 0, 1, 2];\n\nconst rotatedArray2 = [0, 1, 2, 4, 5, 6, 7];\n\n  \n\nconsole.log(\"Minimum element:\", findMin(rotatedArray1)); // Output: 0\n\nconsole.log(\"Minimum element:\", findMin(rotatedArray2)); // Output: 0\n```","x":-3112,"y":500,"width":764,"height":1020},
		{"id":"d1ee4620d421926b","type":"text","text":"**For a 45 minute coding interview with one question, I would budget\n +  5 minute intro\n* 5-10 minute reading question, clarifying all edge cases, and designing the algorithm.  When explaining the algorithm, I would also write down bullets on the coderpad screen.  This makes it easy to reference later when writing the code.  Common mistake is to rush this step.\n  + 15-20 minutes writing the code. As mentioned in previous bullet, use the bullets in algorithm step as a guidance\n","x":-3140,"y":40,"width":660,"height":432},
		{"id":"e1b165f84dcc0da8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-2300,"y":500,"width":550,"height":588},
		{"id":"9fe5b899a2566570","type":"text","text":"## Explanation\nDespite the unsorted array\nBinary search works in this solution works because\n- the array contains 2 sorted subarrays, \nwhen the array is rotated, \nit will be shift relative to the other \n- If the right half is sorted, the right endpoint is moved to the midpoint\n- If the left half is sorted, the left endpoint is moved to the midpoint plus one, focusing the search on the right half.\n","x":-2140,"y":1140,"width":493,"height":440},
		{"id":"7c39023eed1dbc2b","type":"text","text":"##  [Leetcode Problem 151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)\n\nIterative approach\n```js\n\nvar reverseWords = function(s) {\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces and return the reversed string\n\nreturn reversed.trim();\n\n};\n```","x":-1504,"y":716,"width":764,"height":1204},
		{"id":"b1420307298e5e89","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-692,"y":716,"width":550,"height":588},
		{"id":"5950fe748b4b8595","type":"text","text":"## Explanation\nBoth solutions aim to reverse the order of words in the input string `s`.\n\n#### Solution 1:\n\n1. **Trim and Split**: Trim leading and trailing spaces from the input string using `trim()`, then split the string into an array of words using `split(/\\s+/)` to handle multiple spaces between words.\n2. **Reverse and Join**: Reverse the array of words using `reverse()` and join them with a single space using `join(' ')`.\n\n#### Solution 2:\n\n1. **Iterative Approach**: Iterate through each character in the input string.\n2. **Building Words**: Concatenate characters to form each word until a space is encountered.\n3. **Reversing Words**: When a space is encountered, append the current word to the beginning of the result string.\n4. **Finalization**: Trim any leading or trailing spaces from the result string before returning it.\n","x":-532,"y":1356,"width":732,"height":784},
		{"id":"100264f276db2b90","type":"text","text":"Optimized approach using built in functions\n```js\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces, and split the string into an array of words\n\nconst words = s.trim().split(/\\s+/);\n\n// Reverse the array of words and join them with a single space\n\nreturn words.reverse().join(' ');\n\n};\n```","x":-2140,"y":2040,"width":700,"height":440},
		{"id":"a052b013ed6c1ddf","type":"text","text":"Using both approaches\n\n\nUsing both approaches\n\n```js\n\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces from the input string\n\ns = s.trim();\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the trimmed input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces from the result string and return it\n\nreturn reversed.trim();\n\n};\n```","x":-1366,"y":2040,"width":834,"height":1077},
		{"id":"8405d32b1aa494b9","type":"text","text":"## Explanation\n\nhis combined solution first trims the leading and trailing spaces from the input string. Then, it iterates through each character in the trimmed string to build each word while handling spaces. Finally, it returns the reversed string with leading and trailing spaces trimmed.\n\nThis approach effectively combines the benefits of both built-in methods and an iterative approach to solve the problem while satisfying the given conditions.","x":-417,"y":2329,"width":837,"height":302},
		{"id":"c4ca74d7e9fdbcdc","type":"text","text":"## Exponential Time O(2^n)\n```js\n// O(n^2) - Exponential Time\n\nfunction fibonacci(n) {\n\n\tif (n <= 1) {\n\t\n\t\treturn n;\n\t\n\t}\n\t\n\treturn fibonacci(n - 1) + fibonacci(n - 2);\n\n}\n```","x":260,"y":-620,"width":520,"height":440},
		{"id":"808e7143c692499d","type":"text","text":"## Factorial Time (n!)\n```js\n// O(n!) - Factorial Time\nfunction permute(nums) {\n\nlet result = [];\n\npermuteHelper(nums, 0, result);\n\nreturn result;\n\n}\n\n  \n\nfunction permuteHelper(nums, index, result) {\n\n\tif (index === nums.length) {\n\t\n\t\tresult.push(nums.slice()); \n\t\t// Add a copy of the current permutation\n\t\t\n\t\treturn;\n\t\t\n\t}\n\n\tfor (let i = index; i < nums.length; i++) {\n\t\n\t\tswap(nums, index, i);\n\t\t\n\t\tpermuteHelper(nums, index + 1, result);\n\t\t\n\t\tswap(nums, index, i); // Backtrack\n\t\n\t}\n\n}\n\n  \n\nfunction swap(nums, i, j) {\n\n\tlet temp = nums[i];\n\t\n\tnums[i] = nums[j];\n\t\n\tnums[j] = temp;\n\n}\n```","x":780,"y":-1345,"width":651,"height":1098},
		{"id":"2d1c946a0b723e88","type":"text","text":"## Full BIG O Algorithm Examples (Scroll Down)\n```js\n// Linear Time O(1)\n\nfunction accessElement(array, index) {\n\nreturn array[index];\n\n}\n\n  \n\n// O(log n) - Logarithmic Time\n\nfunction binarySearch(array, target) {\n\nlet left = 0;\n\nlet right = array.length - 1;\n\nwhile (left <= right) {\n\nlet mid = Math.floor((left + right) / 2);\n\nif (array[mid] === target) {\n\nreturn mid; // Found the target\n\n} else if (array[mid] < target) {\n\nleft = mid + 1; // Continue searching in the right half\n\n} else {\n\nright = mid - 1; // Continue searching in the left half\n\n}\n\n}\n\nreturn -1; // Target not found\n\n}\n\n// O(n) - Linear Time\n\nfunction findMax(array) {\n\nlet max = array[0];\n\nfor (let i = 1; i < array.length; i++) {\n\nif (array[i] > max) {\n\nmax = array[i];\n\n}\n\n}\n\nreturn max;\n\n}\n\n// O(n log n) - Linearithmic Time\n\nfunction mergeSort(array) {\n\nif (array.length <= 1) {\n\nreturn array;\n\n}\n\nconst mid = Math.floor(array.length / 2);\n\nconst left = mergeSort(array.slice(0, mid));\n\nconst right = mergeSort(array.slice(mid));\n\nreturn merge(left, right);\n\n}\n\n  \n\nfunction merge(left, right) {\n\nlet result = [];\n\nlet leftIndex = 0;\n\nlet rightIndex = 0;\n\nwhile (leftIndex < left.length && rightIndex < right.length) {\n\nif (left[leftIndex] < right[rightIndex]) {\n\nresult.push(left[leftIndex]);\n\nleftIndex++;\n\n} else {\n\nresult.push(right[rightIndex]);\n\nrightIndex++;\n\n}\n\n}\n\nreturn result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n\n}\n\n// O(n^2) - Quadratic Time\n\nfunction bubbleSort(array) {\n\nconst n = array.length;\n\nfor (let i = 0; i < n - 1; i++) {\n\nfor (let j = 0; j < n - i - 1; j++) {\n\nif (array[j] > array[j + 1]) {\n\n// Swap array[j] and array[j+1]\n\nlet temp = array[j];\n\narray[j] = array[j + 1];\n\narray[j + 1] = temp;\n\n}\n\n}\n\n}\n\nreturn array;\n\n}\n\n// O(n^2) - Exponential Time\n\nfunction fibonacci(n) {\n\nif (n <= 1) {\n\nreturn n;\n\n}\n\nreturn fibonacci(n - 1) + fibonacci(n - 2);\n\n}\n\n// O(n!) - Factorial Time\n\nfunction permute(nums) {\n\nlet result = [];\n\npermuteHelper(nums, 0, result);\n\nreturn result;\n\n}\n\n```","x":1560,"y":-1345,"width":859,"height":1330},
		{"id":"992cfe08044d1dc7","type":"file","file":"1_Images/Big O Time Complexity Chart.png","x":-1556,"y":-1380,"width":2228,"height":517},
		{"id":"410b42bed57268f5","type":"text","text":"##  [Leetcode 26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n```js\nfunction removeDuplicates(nums) {\n\n// Initialize the index for unique elements\n\nlet uniqueIndex = 0;\n\n  \n\n// Iterate through the array starting from the second element\n\nfor (let i = 1; i < nums.length; i++) {\n\n// Compare the current element with the previous one\n\nif (nums[i] !== nums[uniqueIndex]) {\n\n// If different, update the unique element index and copy the value\n\nuniqueIndex++;\n\nnums[uniqueIndex] = nums[i];\n\n}\n\n}\n\n  \n\n// Return the number of unique elements (length up to uniqueIndex + 1)\n\nreturn uniqueIndex + 1;\n\n}\n\n  \n\n// Test cases\n\nlet nums1 = [1, 1, 2]; // Expected output: 2\n\nconsole.log(removeDuplicates(nums1)); // Output: 2\n\nconsole.log(nums1); // Output: [1, 2, 2]\n\n  \n\nlet nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]; // Expected output: 5\n\nconsole.log(removeDuplicates(nums2)); // Output: 5\n\nconsole.log(nums2); // Output: [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] (Only the first 5 elements are important)\n```","x":380,"y":840,"width":940,"height":1220},
		{"id":"fc7a69636aa78155","type":"text","text":"##  [Leetcode Problem 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\n\n\nBoth approaches have the same implementation because the iterative approach already achieves O(log n) time complexity. The optimized approach using binary search is essentially the same as the iterative approach.\n```js\nvar spiralOrder = function(matrix) {\n\n\tif (matrix.length === 0) \n\t\treturn [];\n\t\n\tlet result = [];\n\t\n\tlet rowBegin = 0;\n\t\n\tlet rowEnd = matrix.length - 1;\n\t\n\tlet colBegin = 0;\n\t\n\tlet colEnd = matrix[0].length - 1;\n\t\n\twhile (rowBegin <= rowEnd && colBegin <= colEnd) {\n\t\n\t\t// Traverse Right\n\t\t\n\t\tfor (let i = colBegin; i <= colEnd; i++) {\n\t\t\n\t\tresult.push(matrix[rowBegin][i]);\n\t\t\n\t\t}\n\t\t\n\t\trowBegin++;\n\t\t\n\t\t// Traverse Down\n\t\t\n\t\tfor (let i = rowBegin; i <= rowEnd; i++) {\n\t\t\n\t\tresult.push(matrix[i][colEnd]);\n\t\t\n\t\t}\n\t\t\n\t\tcolEnd--;\n\t\n\t\t// Traverse Left\n\t\t\n\t\tif (rowBegin <= rowEnd) {\n\t\t\n\t\t\tfor (let i = colEnd; i >= colBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[rowEnd][i]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\trowEnd--;\n\t\t\n\t\t// Traverse Up\n\t\t\n\t\tif (colBegin <= colEnd) {\n\t\t\n\t\t\tfor (let i = rowEnd; i >= rowBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[i][colBegin]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tcolBegin++;\n\t\t\n\t}\n\t\n\treturn result;\n\n};\n```","x":-3440,"y":2720,"width":884,"height":1640},
		{"id":"5e9dc52c50f3cf06","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-2508,"y":2720,"width":550,"height":588},
		{"id":"ac60ff8000caf58e","type":"text","text":"## Explanation\nDespite the unsorted array\nBinary search works in this solution works because\n- the array contains 2 sorted subarrays, \nwhen the array is rotated, \nit will be shift relative to the other \n- If the right half is sorted, the right endpoint is moved to the midpoint\n- If the left half is sorted, the left endpoint is moved to the midpoint plus one, focusing the search on the right half.\n","x":-2348,"y":3360,"width":493,"height":440},
		{"id":"042d6e0fdd2136de","type":"text","text":"##  [Leetcode Problem 1. Two Sum](https://leetcode.com/problems/two-sum/)\n\n```js\nvar twoSum = function(nums, target) {\n\nlet map = new Map()\n\nfor (let i = 0; i < nums.length; i++) {\n\nlet diff = target - nums[i]\n\nif (map.has(diff)) {\n\nreturn [i, map.get(diff)]\n\n}\n\nmap.set(nums[i], i)\n\n}\n\n};\n```\n\n\n\n\n","x":1680,"y":560,"width":780,"height":610},
		{"id":"7ce85dc61b902073","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":2640,"y":546,"width":550,"height":588},
		{"id":"6f758c01cc58bef8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":1680,"y":1280,"width":550,"height":588}
	],
	"edges":[
		{"id":"1326a80dda13ca35","fromNode":"94b330dcf24cb4cc","fromSide":"right","toNode":"29072537a1985352","toSide":"left"},
		{"id":"1fbac650880a610f","fromNode":"29072537a1985352","fromSide":"right","toNode":"13807d0f7b42aab3","toSide":"left"},
		{"id":"6bb089a48dfa4e65","fromNode":"13807d0f7b42aab3","fromSide":"right","toNode":"e5899847cdd8566b","toSide":"left"},
		{"id":"ca00c78dfbb5fff8","fromNode":"e5899847cdd8566b","fromSide":"right","toNode":"787dace1ed352460","toSide":"left"},
		{"id":"f3a528a2687013e6","fromNode":"787dace1ed352460","fromSide":"right","toNode":"c4ca74d7e9fdbcdc","toSide":"left"},
		{"id":"d286fc472225a5d7","fromNode":"c4ca74d7e9fdbcdc","fromSide":"right","toNode":"808e7143c692499d","toSide":"left"},
		{"id":"b764c0a2d076cc12","fromNode":"e1b165f84dcc0da8","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"1274efd18c2d7c33","fromNode":"9fe5b899a2566570","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"85af152bfee329da","fromNode":"b1420307298e5e89","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"e716060380213b01","fromNode":"5950fe748b4b8595","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"b06133d132f0e4a6","fromNode":"7c39023eed1dbc2b","fromSide":"bottom","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"49c114b25ae72f59","fromNode":"100264f276db2b90","fromSide":"top","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"12f80639a3dd3627","fromNode":"8405d32b1aa494b9","fromSide":"left","toNode":"a052b013ed6c1ddf","toSide":"right"},
		{"id":"1b122113677b0a4d","fromNode":"992cfe08044d1dc7","fromSide":"right","toNode":"2d1c946a0b723e88","toSide":"top"},
		{"id":"73e42d741dcbf8f4","fromNode":"992cfe08044d1dc7","fromSide":"left","toNode":"94b330dcf24cb4cc","toSide":"top"},
		{"id":"09295a9d59974d5b","fromNode":"5e9dc52c50f3cf06","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"2332491818f44863","fromNode":"ac60ff8000caf58e","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"9eed7259372fb601","fromNode":"042d6e0fdd2136de","fromSide":"right","toNode":"7ce85dc61b902073","toSide":"top"},
		{"id":"fdd8a0dc4f72677e","fromNode":"410b42bed57268f5","fromSide":"right","toNode":"6f758c01cc58bef8","toSide":"left"}
	]
}