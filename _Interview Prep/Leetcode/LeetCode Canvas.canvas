{
	"nodes":[
		{"id":"11aeb1e95d080cfc","type":"text","text":"## Linearithmic Time O(n log n)\n```js\n// Linearithmic Time O(n log n)\nfunction mergeSort(array) {\n  if (array.length <= 1) {\n      return array;\n  }\n  const mid = Math.floor(array.length / 2);\n  const left = mergeSort(array.slice(0, mid));\n  const right = mergeSort(array.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n          result.push(left[leftIndex]);\n          leftIndex++;\n      } else {\n          result.push(right[rightIndex]);\n          rightIndex++;\n      }\n  }\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n```","x":-2134,"y":5624,"width":680,"height":853},
		{"id":"6666f0c6d89f5208","type":"text","text":"## Quadratic Time O(n^2)\n```js\n// Quadratic Time O(n^2)\nfunction bubbleSort(array) {\n  const n = array.length;\n  for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n          if (array[j] > array[j + 1]) {\n              // Swap array[j] and array[j+1]\n              let temp = array[j];\n              array[j] = array[j + 1];\n              array[j + 1] = temp;\n          }\n      }\n  }\n  return array;\n}\n\n```","x":-1392,"y":5624,"width":669,"height":513},
		{"id":"e99b3f543107da12","type":"text","text":"## Exponential Time O(2^n)\n```js\n// Exponential Time O(2^n)\nfunction fibonacci(n) {\n  if (n <= 1) {\n      return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```","x":-663,"y":5657,"width":580,"height":440},
		{"id":"e5d67b205a2a1af4","type":"text","text":"# Big O Notation Breakdown\n\nRelated: #bigo #dsa #time_compexity #deepdive \n[[Big O Time Complexity Chart.png]]\n[[Big O and Time Complexity.canvas|Big O and Time Complexity]]","x":-3671,"y":4640,"width":751,"height":361},
		{"id":"17968efa80a893a4","type":"text","text":"## Logarithmic Time O(log n)\n\n```js\n// Logarithmic Time O(log n)\nfunction binarySearch(array, target) {\n  let left = 0;\n  let right = array.length - 1;\n  \n  while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (array[mid] === target) {\n          return mid; // Found the target\n      } else if (array[mid] < target) {\n          left = mid + 1; // Continue searching in the right half\n      } else {\n          right = mid - 1; // Continue searching in the left half\n      }\n  }\n  \n  return -1; // Target not found\n}\n\n```","x":-3504,"y":5677,"width":600,"height":800},
		{"id":"9403e39aa9f03dd6","type":"text","text":"## Constant Time O(1)\n\n```js\n// Constant Time O(1)\nfunction accessElement(array, index) {\n  return array[index];\n}\n```","x":-3453,"y":5216,"width":440,"height":320},
		{"id":"1ee8755122131d78","type":"text","text":"## Linear Time O(n)\n```js\n// Linear Time O(n)\nfunction findMax(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n      if (array[i] > max) {\n          max = array[i];\n      }\n  }\n  return max;\n}\n\n```","x":-2801,"y":5627,"width":549,"height":510},
		{"id":"472a0ef196813e5e","type":"text","text":"## Factorial Time O(n!)\n```js\n// Factorial Time O(n!)\nfunction permute(nums) {\n  let result = [];\n  permuteHelper(nums, 0, result);\n  return result;\n}\n\nfunction permuteHelper(nums, index, result) {\n  if (index === nums.length) {\n      result.push(nums.slice()); // Add a copy of the current permutation\n      return;\n  }\n  for (let i = index; i < nums.length; i++) {\n      swap(nums, index, i);\n      permuteHelper(nums, index + 1, result);\n      swap(nums, index, i); // Backtrack\n  }\n}\n\nfunction swap(nums, i, j) {\n  let temp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = temp;\n}\n\n```","x":39,"y":5588,"width":651,"height":1098},
		{"id":"9bb757959c0f5031","type":"file","file":"1_Images/Big O Time Complexity Chart.png","x":-2841,"y":4780,"width":3086,"height":716},
		{"id":"ff3e76d7fb92e90b","type":"text","text":"*45min Technical Interview Breakdown*\n+ *5 minutes:* intro / reading question\n+ *5-10 minutes:* clarifying all edge cases, and designing the algorithm.Â Write these in bullet points that you can refer back to while writing your code.\n+ *15-20 minutes:* writing the code.\n+ *Remaining Time:* to Test and Debug. ","x":-2800,"y":1731,"width":959,"height":341},
		{"id":"6048d7c76ce951fa","type":"text","text":"##  [Leetcode Problem 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\n\nRelated: #findmin #leetcodeproblem_153\n\n```js\n\nfunction findMin(nums) {\n\n\tlet left = 0;\n\t\n\tlet right = nums.length - 1;\n\t\n\twhile (left < right) {\n\t\n\t\tconst mid = Math.floor((left + right) / 2);\n\t\n\t\tif (nums[mid] < nums[right]) {\n\t\t\n\t\t\tright = mid;\n\t\t\n\t\t} else {\n\t\t\n\t\t\tleft = mid + 1;\n\t\t\n\t\t}\n\t\n\t}\n\n\treturn nums[left];\n\n}\n\n  \n\n// Example usage:\n\nconst rotatedArray1 = [4, 5, 6, 7, 0, 1, 2];\n\nconst rotatedArray2 = [0, 1, 2, 4, 5, 6, 7];\n\n  \n\nconsole.log(\"Minimum element:\", findMin(rotatedArray1)); // Output: 0\n\nconsole.log(\"Minimum element:\", findMin(rotatedArray2)); // Output: 0\n```","x":-3120,"y":2164,"width":1084,"height":1676},
		{"id":"ac7f001e68299d89","type":"text","text":"# Leetcode Problem Breakdown\n\nRelated: #dsa #leetcode #interview_prep\n[[Interview Prep Overview]] #insightful #deepdive \n#coding_strategy","x":-3560,"y":1520,"width":658,"height":281},
		{"id":"e1b165f84dcc0da8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### Codepad \n### 15-20mins write out code \n- include bullets on codepad screen\n- refer to documentation for shorthands if possible\n\n### 10 mins / remaining time to test and debug ","x":-1760,"y":1801,"width":760,"height":956},
		{"id":"9fe5b899a2566570","type":"text","text":"## Explanation\nDespite the unsorted array\nBinary search works in this solution works because\n- the array contains 2 sorted subarrays, \nwhen the array is rotated, \nit will be shift relative to the other \n- If the right half is sorted, the right endpoint is moved to the midpoint\n- If the left half is sorted, the left endpoint is moved to the midpoint plus one, focusing the search on the right half.\n","x":-1760,"y":2837,"width":493,"height":640},
		{"id":"b1420307298e5e89","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### Codepad \n### 15-20mins write out code \n- include bullets on codepad screen\n- refer to documentation for shorthands if possible\n\n### 10 mins / remaining time to test and debug ","x":3620,"y":1776,"width":820,"height":1004},
		{"id":"5950fe748b4b8595","type":"text","text":"## Explanation\nBoth solutions aim to reverse the order of words in the input string `s`.\n#### Iterative approach:\n\n1. **Iterative Approach**: Iterate through each character in the input string.\n2. **Building Words**: Concatenate characters to form each word until a space is encountered.\n3. **Reversing Words**: When a space is encountered, append the current word to the beginning of the result string.\n4. **Finalization**: Trim any leading or trailing spaces from the result string before returning it.\n","x":3708,"y":2814,"width":1132,"height":606},
		{"id":"8405d32b1aa494b9","type":"text","text":"## Explanation\n\n#### Both Iterative / Optimized Approaches\nThis combined solution-- \n+ 1st trims the leading and trailing spaces from the input string. \n+ 2nd, it iterates through each character in the trimmed string to build each word while handling spaces. \n+ 3rd, it returns the reversed string with leading and trailing spaces trimmed.\n\nThis approach effectively combines the benefits of both built-in methods and an iterative approach to solve the problem while satisfying the given conditions.","x":4120,"y":3830,"width":837,"height":620},
		{"id":"fc7a69636aa78155","type":"text","text":"##  [Leetcode Problem 54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\nRelated: #spiralmatrix #leetcodeproblem_54\n\n```js\nvar spiralOrder = function(matrix) {\n\n\tif (matrix.length === 0) \n\t\treturn [];\n\t\n\tlet result = [];\n\t\n\tlet rowBegin = 0;\n\t\n\tlet rowEnd = matrix.length - 1;\n\t\n\tlet colBegin = 0;\n\t\n\tlet colEnd = matrix[0].length - 1;\n\t\n\twhile (rowBegin <= rowEnd && colBegin <= colEnd) {\n\t\n\t\t// Traverse Right\n\t\t\n\t\tfor (let i = colBegin; i <= colEnd; i++) {\n\t\t\n\t\tresult.push(matrix[rowBegin][i]);\n\t\t\n\t\t}\n\t\t\n\t\trowBegin++;\n\t\t\n\t\t// Traverse Down\n\t\t\n\t\tfor (let i = rowBegin; i <= rowEnd; i++) {\n\t\t\n\t\tresult.push(matrix[i][colEnd]);\n\t\t\n\t\t}\n\t\t\n\t\tcolEnd--;\n\t\n\t\t// Traverse Left\n\t\t\n\t\tif (rowBegin <= rowEnd) {\n\t\t\n\t\t\tfor (let i = colEnd; i >= colBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[rowEnd][i]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\trowEnd--;\n\t\t\n\t\t// Traverse Up\n\t\t\n\t\tif (colBegin <= colEnd) {\n\t\t\n\t\t\tfor (let i = rowEnd; i >= rowBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[i][colBegin]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tcolBegin++;\n\t\t\n\t}\n\t\n\treturn result;\n\n};\n```","x":160,"y":1778,"width":1200,"height":2480},
		{"id":"5e9dc52c50f3cf06","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### Codepad \n### 15-20mins write out code \n- include bullets on codepad screen\n- refer to documentation for shorthands if possible\n\n### 10 mins / remaining time to test and debug ","x":1480,"y":1778,"width":840,"height":1002},
		{"id":"ac60ff8000caf58e","type":"text","text":"## Explanation\nThis function takes a matrix as input & returns all elements of the matrix in spiral order. \n+ It initializes four variables to track the boundaries of the matrix. \n+ Then, it iterates through the matrix in a spiral pattern, \n+ pushing each element into the `result` array. \n+ Finally, it returns the `result` array containing the elements in spiral order.\n","x":1640,"y":2898,"width":600,"height":560},
		{"id":"100264f276db2b90","type":"text","text":"### Optimized approach using built in functions\n```js\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces, and split the string into an array of words\n\nconst words = s.trim().split(/\\s+/);\n\n// Reverse the array of words and join them with a single space\n\nreturn words.reverse().join(' ');\n\n};\n```","x":2346,"y":3830,"width":751,"height":620},
		{"id":"7c39023eed1dbc2b","type":"text","text":"##  [Leetcode Problem 151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)\n\nRelated: #reversewords #leetcodeproblem_151\n### Iterative approach\n```js\n\nvar reverseWords = function(s) {\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces and return the reversed string\n\nreturn reversed.trim();\n\n};\n```","x":2500,"y":1776,"width":1060,"height":1722},
		{"id":"a052b013ed6c1ddf","type":"text","text":"### Using both approaches\n\n\nUsing both approaches\n\n```js\n\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces from the input string\n\ns = s.trim();\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the trimmed input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces from the result string and return it\n\nreturn reversed.trim();\n\n};\n```","x":3143,"y":3710,"width":834,"height":1077},
		{"id":"cd3f2f1eceb4f082","type":"text","text":"### Algorithm Explanation:\n\n1. **Initialization:**\n    \n    - Initialize two pointers, `left` and `right`, representing the start and end indices of the array, respectively.\n2. **Binary Search:**\n    \n    - Use a binary search approach to find the minimum element in the rotated sorted array.\n    - In each iteration of the `while` loop, calculate the `mid` index as the midpoint between `left` and `right`.\n3. **Comparison:**\n    \n    - Compare the value at the `mid` index (`nums[mid]`) with the value at the `right` index (`nums[right]`).\n    - If `nums[mid]` is less than `nums[right]`, it means the minimum element lies in the left half of the array. Update `right = mid`.\n    - Otherwise, the minimum element lies in the right half of the array. Update `left = mid + 1`.\n4. **Termination:**\n    \n    - Continue this process until `left` is no longer less than `right`, indicating that the search space has been narrowed down to a single element.\n5. **Return:**\n    \n    - Return the element at the `left` index, which represents the minimum element in the array.\n\n### Iteration Explanation:\n\n- In each iteration of the `while` loop, the algorithm:\n    - Calculates the midpoint index `mid`.\n    - Compares the value at `mid` with the value at `right`.\n    - Adjusts the search space (`left` or `right`) based on the comparison result.\n- The loop continues until the search space is reduced to a single element (`left` becomes equal to `right`).\n\n### Example:\n\n- For the given rotated sorted array `[4, 5, 6, 7, 0, 1, 2]`:\n    - The algorithm iterates to find the minimum element, which is `0`.\n- For the sorted array `[0, 1, 2, 4, 5, 6, 7]`:\n    - The minimum element is already at the beginning of the array, and the algorithm correctly returns `0`.","x":-940,"y":2600,"width":840,"height":1658},
		{"id":"1137b26d819e41a7","type":"text","text":"## Explanation\nBoth solutions aim to reverse the order of words in the input string `s`.\n\n#### Optimized approach:\n\n1. **Trim and Split**: Trim leading and trailing spaces from the input string using `trim()`, then split the string into an array of words using `split(/\\s+/)` to handle multiple spaces between words.\n2. **Reverse and Join**: Reverse the array of words using `reverse()` and join them with a single space using `join(' ')`.","x":1620,"y":3920,"width":593,"height":740},
		{"id":"042d6e0fdd2136de","type":"text","text":"##  [Leetcode Problem 1. Two Sum](https://leetcode.com/problems/two-sum/)\nRelated: #twosum #leetcodeproblem_1\n\n```js\nvar twoSum = function(nums, target) {\n\nlet map = new Map()\n\nfor (let i = 0; i < nums.length; i++) {\n\nlet diff = target - nums[i]\n\nif (map.has(diff)) {\n\nreturn [i, map.get(diff)]\n\n}\n\nmap.set(nums[i], i)\n\n}\n\n};\n```\n\n\n\n\n","x":8280,"y":1746,"width":780,"height":773},
		{"id":"7ce85dc61b902073","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### Codepad \n### 15-20mins write out code \n- include bullets on codepad screen\n- refer to documentation for shorthands if possible\n\n### 10 mins / remaining time to test and debug ","x":9320,"y":1826,"width":880,"height":946},
		{"id":"e3c430432d386439","type":"text","text":"### Explanation:\n\n1. **Map Initialization**: initialize an empty Map called `map`. \n\t + map stores each element of the array `nums` along with its index.\n    \n2. **Iteration through Array**: iterate through the `nums` array using a for loop. \n\t- For each element `nums[i]` in the array:\n    \n3. **Calculating the Difference**: calculates difference `diff` by subtracting the current element `nums[i]` from target value. \n\t- `diff` represents the value that needs to be searched in the array to find the complement of the current element that sums up to the target.\n    \n4. **Checking if the Difference Exists**: If `map` contains the calculated difference `diff` as a key then the complement of the current element exists in the array, and the current element along with the complement will sum up to the target.\n    \n5. **Returning the Indices**: If the difference `diff` exists in the map, it returns an array containing the indices of the current element `i` and the index stored in the map corresponding to the difference `diff`.\n    \n6. **Storing in Map**: If the difference `diff` doesn't exist in the map, it means that the complement hasn't been found yet. So, it stores the current element `nums[i]` along with its index `i` in the map `map`.### ","x":8280,"y":2626,"width":997,"height":960},
		{"id":"2d7511d4d4e896ba","type":"text","text":"### Why the Algorithm Works:\n\n- The algorithm utilizes a hash map to store the elements of the array + their indices. This allows for constant-time lookups to check if the complement of the current element exists in the array.\n    \n- By iterating through the array once and storing elements in the map, the algorithm achieves a time complexity of O(n), where n is the number of elements in the array.\n    \n- When it finds a complement in the map, it immediately returns the indices of the current element and its complement, ensuring that the solution is found efficiently in a single pass through the array.\n    \n- **Concluding** the algorithm finds the indices of the two numbers that add up to the target without using the same element twice and returns the answer in any order.","x":9380,"y":2886,"width":1021,"height":580},
		{"id":"6f758c01cc58bef8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### Codepad \n### 15-20mins write out code \n- include bullets on codepad screen\n- refer to documentation for shorthands if possible\n\n### 10 mins / remaining time to test and debug ","x":6903,"y":1704,"width":820,"height":946},
		{"id":"410b42bed57268f5","type":"text","text":"##  [Leetcode 26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\nRelated: #removeduplicates #leetcodeproblem_26\n```js\nfunction removeDuplicates(nums) {\n\n// Initialize the index for unique elements\n\nlet uniqueIndex = 0;\n\n  \n\n// Iterate through the array starting from the second element\n\nfor (let i = 1; i < nums.length; i++) {\n\n// Compare the current element with the previous one\n\nif (nums[i] !== nums[uniqueIndex]) {\n\n// If different, update the unique element index and copy the value\n\nuniqueIndex++;\n\nnums[uniqueIndex] = nums[i];\n\n}\n\n}\n\n  \n\n// Return the number of unique elements (length up to uniqueIndex + 1)\n\nreturn uniqueIndex + 1;\n\n}\n\n  \n\n// Test cases\n\nlet nums1 = [1, 1, 2]; // Expected output: 2\n\nconsole.log(removeDuplicates(nums1)); // Output: 2\n\nconsole.log(nums1); // Output: [1, 2, 2]\n\n  \n\nlet nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]; // Expected output: 5\n\nconsole.log(removeDuplicates(nums2)); // Output: 5\n\nconsole.log(nums2); // Output: [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] (Only the first 5 elements are important)\n```","x":5443,"y":1682,"width":1420,"height":1888},
		{"id":"62eec70da687291b","type":"text","text":"### Explanation:\n\n1. **Initialization**: It initializes a variable `uniqueIndex` to keep track of the index of unique elements in the array. This starts at 0 since the first element is always unique.\n    \n2. **Iteration**: It iterates through the array `nums` starting from the second element (index 1). This is done using a `for` loop.\n    \n3. **Comparison**: For each element at index `i`, it compares the current element `nums[i]` with the previous unique element `nums[uniqueIndex]`. If the current element is different from the previous unique element, it means it's a new unique element.\n    \n4. **Updating Unique Elements**: If the current element is different, it increments the `uniqueIndex` variable to move it to the next position and assigns the value of the current element `nums[i]` to the new unique index in the array. This effectively overwrites any duplicate elements with the new unique element.\n    \n5. **Return**: After the loop completes, it returns `uniqueIndex + 1`, which represents the number of unique elements in the array. Adding 1 is necessary because `uniqueIndex` is zero-based, so it accounts for the length of the unique elements.","x":5443,"y":3720,"width":997,"height":842},
		{"id":"16b5aeda3f567314","type":"text","text":"### Why the Algorithm Works:\n    \nThe input array `nums` is sorted in non-decreasing order. \n+ This allows the algorithm to identify duplicates by comparing each element with the previous unique element. \n+ By overwriting duplicates with new unique elements in-place, it maintains the order of unique elements and satisfies the requirements of the problem. \n+ The algorithm runs in O(n) time complexity, where n is the length of the input array, because it iterates through the array only once.","x":6760,"y":3720,"width":780,"height":562}
	],
	"edges":[
		{"id":"b764c0a2d076cc12","fromNode":"e1b165f84dcc0da8","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"1274efd18c2d7c33","fromNode":"9fe5b899a2566570","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"85af152bfee329da","fromNode":"b1420307298e5e89","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"e716060380213b01","fromNode":"5950fe748b4b8595","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"b06133d132f0e4a6","fromNode":"7c39023eed1dbc2b","fromSide":"bottom","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"49c114b25ae72f59","fromNode":"100264f276db2b90","fromSide":"top","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"12f80639a3dd3627","fromNode":"8405d32b1aa494b9","fromSide":"left","toNode":"a052b013ed6c1ddf","toSide":"right"},
		{"id":"09295a9d59974d5b","fromNode":"5e9dc52c50f3cf06","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"2332491818f44863","fromNode":"ac60ff8000caf58e","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"9eed7259372fb601","fromNode":"042d6e0fdd2136de","fromSide":"right","toNode":"7ce85dc61b902073","toSide":"top"},
		{"id":"fdd8a0dc4f72677e","fromNode":"410b42bed57268f5","fromSide":"right","toNode":"6f758c01cc58bef8","toSide":"left"},
		{"id":"4c87b9a41501ba96","fromNode":"ff3e76d7fb92e90b","fromSide":"right","toNode":"e1b165f84dcc0da8","toSide":"top"},
		{"id":"4467901847372f9b","fromNode":"11aeb1e95d080cfc","fromSide":"right","toNode":"6666f0c6d89f5208","toSide":"left"},
		{"id":"39354a90d7559e27","fromNode":"1ee8755122131d78","fromSide":"right","toNode":"11aeb1e95d080cfc","toSide":"left"},
		{"id":"55ba61c26e7d36b7","fromNode":"6666f0c6d89f5208","fromSide":"right","toNode":"e99b3f543107da12","toSide":"left"},
		{"id":"7e0e11561cd61b70","fromNode":"e99b3f543107da12","fromSide":"right","toNode":"472a0ef196813e5e","toSide":"left"},
		{"id":"c5e5f9a48c2ebd07","fromNode":"e5d67b205a2a1af4","fromSide":"bottom","toNode":"9bb757959c0f5031","toSide":"left"},
		{"id":"052135cac0414a50","fromNode":"17968efa80a893a4","fromSide":"right","toNode":"1ee8755122131d78","toSide":"left"},
		{"id":"a18c4f76f5373ca4","fromNode":"9403e39aa9f03dd6","fromSide":"right","toNode":"17968efa80a893a4","toSide":"left"},
		{"id":"bcdb8b4921478c23","fromNode":"9bb757959c0f5031","fromSide":"left","toNode":"9403e39aa9f03dd6","toSide":"top"},
		{"id":"39af7957694e0783","fromNode":"ac7f001e68299d89","fromSide":"right","toNode":"ff3e76d7fb92e90b","toSide":"left"},
		{"id":"5265996540b98442","fromNode":"9fe5b899a2566570","fromSide":"right","toNode":"cd3f2f1eceb4f082","toSide":"left"},
		{"id":"8043818503e104ca","fromNode":"042d6e0fdd2136de","fromSide":"bottom","toNode":"e3c430432d386439","toSide":"top"},
		{"id":"b0ab48996b000605","fromNode":"e3c430432d386439","fromSide":"right","toNode":"2d7511d4d4e896ba","toSide":"left"},
		{"id":"fd1b6cf16a739020","fromNode":"1137b26d819e41a7","fromSide":"right","toNode":"100264f276db2b90","toSide":"left"},
		{"id":"c6c2740947b02874","fromNode":"410b42bed57268f5","fromSide":"bottom","toNode":"62eec70da687291b","toSide":"top"},
		{"id":"72315380e0534946","fromNode":"62eec70da687291b","fromSide":"right","toNode":"16b5aeda3f567314","toSide":"left"}
	]
}