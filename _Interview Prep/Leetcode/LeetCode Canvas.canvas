{
	"nodes":[
		{"id":"7c39023eed1dbc2b","type":"text","text":"##  [Leetcode Problem 151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)\n\n### Iterative approach\n```js\n\nvar reverseWords = function(s) {\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces and return the reversed string\n\nreturn reversed.trim();\n\n};\n```","x":-1504,"y":716,"width":764,"height":1204},
		{"id":"b1420307298e5e89","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-692,"y":716,"width":550,"height":588},
		{"id":"61a774cdfa6f2d91","type":"text","text":"## Exponential Time O(2^n)\n```js\n// Exponential Time O(2^n)\nfunction fibonacci(n) {\n  if (n <= 1) {\n      return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n```","x":508,"y":-564,"width":580,"height":440},
		{"id":"4ecde0f87437ab35","type":"text","text":"## Quadratic Time O(n^2)\n```js\n// Quadratic Time O(n^2)\nfunction bubbleSort(array) {\n  const n = array.length;\n  for (let i = 0; i < n - 1; i++) {\n      for (let j = 0; j < n - i - 1; j++) {\n          if (array[j] > array[j + 1]) {\n              // Swap array[j] and array[j+1]\n              let temp = array[j];\n              array[j] = array[j + 1];\n              array[j + 1] = temp;\n          }\n      }\n  }\n  return array;\n}\n\n```","x":-221,"y":-597,"width":669,"height":513},
		{"id":"ea714bb66edcbcac","type":"text","text":"## Linearithmic Time O(n log n)\n```js\n// Linearithmic Time O(n log n)\nfunction mergeSort(array) {\n  if (array.length <= 1) {\n      return array;\n  }\n  const mid = Math.floor(array.length / 2);\n  const left = mergeSort(array.slice(0, mid));\n  const right = mergeSort(array.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n  while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n          result.push(left[leftIndex]);\n          leftIndex++;\n      } else {\n          result.push(right[rightIndex]);\n          rightIndex++;\n      }\n  }\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n```","x":-963,"y":-597,"width":680,"height":853},
		{"id":"cb309539c2d47bde","type":"file","file":"1_Images/Big O Time Complexity Chart.png","x":-1670,"y":-1441,"width":3086,"height":716},
		{"id":"93252cdd7c373e4d","type":"text","text":"# Big O Notation Breakdown\n\nRelated: #bigo #time_compexity #deepdive \n[[Big O Time Complexity Chart.png]]\n[[Big O and Time Complexity.canvas|Big O and Time Complexity]]","x":-2500,"y":-1501,"width":658,"height":281},
		{"id":"56e4552d7cce36a6","type":"text","text":"## Constant Time O(1)\n\n```js\n// Constant Time O(1)\nfunction accessElement(array, index) {\n  return array[index];\n}\n```","x":-2282,"y":-1005,"width":440,"height":320},
		{"id":"9d765ea7783a5508","type":"text","text":"## Logarithmic Time O(log n)\n\n```js\n// Logarithmic Time O(log n)\nfunction binarySearch(array, target) {\n  let left = 0;\n  let right = array.length - 1;\n  \n  while (left <= right) {\n      let mid = Math.floor((left + right) / 2);\n      if (array[mid] === target) {\n          return mid; // Found the target\n      } else if (array[mid] < target) {\n          left = mid + 1; // Continue searching in the right half\n      } else {\n          right = mid - 1; // Continue searching in the left half\n      }\n  }\n  \n  return -1; // Target not found\n}\n\n```","x":-2333,"y":-544,"width":600,"height":800},
		{"id":"bbee8ab28130d7d4","type":"text","text":"## Linear Time O(n)\n```js\n// Linear Time O(n)\nfunction findMax(array) {\n  let max = array[0];\n  for (let i = 1; i < array.length; i++) {\n      if (array[i] > max) {\n          max = array[i];\n      }\n  }\n  return max;\n}\n\n```","x":-1630,"y":-594,"width":549,"height":510},
		{"id":"fcf2a7234a8bfcd7","type":"text","text":"## Factorial Time O(n!)\n```js\n// Factorial Time O(n!)\nfunction permute(nums) {\n  let result = [];\n  permuteHelper(nums, 0, result);\n  return result;\n}\n\nfunction permuteHelper(nums, index, result) {\n  if (index === nums.length) {\n      result.push(nums.slice()); // Add a copy of the current permutation\n      return;\n  }\n  for (let i = index; i < nums.length; i++) {\n      swap(nums, index, i);\n      permuteHelper(nums, index + 1, result);\n      swap(nums, index, i); // Backtrack\n  }\n}\n\nfunction swap(nums, i, j) {\n  let temp = nums[i];\n  nums[i] = nums[j];\n  nums[j] = temp;\n}\n\n```","x":1210,"y":-633,"width":651,"height":1098},
		{"id":"e1b165f84dcc0da8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-2440,"y":808,"width":760,"height":792},
		{"id":"ff3e76d7fb92e90b","type":"text","text":"*45min Technical Interview Breakdown*\n+ *5 minutes:* intro / reading question\n+ *5-10 minutes:* clarifying all edge cases, and designing the algorithm.Â  \n+ *15-20 minutes:* writing the code.\n+ *Remaining Time:* to Test and Debug. ","x":-3477,"y":375,"width":959,"height":341},
		{"id":"6048d7c76ce951fa","type":"text","text":"##  [Leetcode Problem 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\n\n\nBoth approaches have the same implementation because the iterative approach already achieves O(log n) time complexity. The optimized approach using binary search is essentially the same as the iterative approach.\n```js\n\nfunction findMin(nums) {\n\n\tlet left = 0;\n\t\n\tlet right = nums.length - 1;\n\t\n\twhile (left < right) {\n\t\n\t\tconst mid = Math.floor((left + right) / 2);\n\t\n\t\tif (nums[mid] < nums[right]) {\n\t\t\n\t\t\tright = mid;\n\t\t\n\t\t} else {\n\t\t\n\t\t\tleft = mid + 1;\n\t\t\n\t\t}\n\t\n\t}\n\n\treturn nums[left];\n\n}\n\n  \n\n// Example usage:\n\nconst rotatedArray1 = [4, 5, 6, 7, 0, 1, 2];\n\nconst rotatedArray2 = [0, 1, 2, 4, 5, 6, 7];\n\n  \n\nconsole.log(\"Minimum element:\", findMin(rotatedArray1)); // Output: 0\n\nconsole.log(\"Minimum element:\", findMin(rotatedArray2)); // Output: 0\n```","x":-3477,"y":808,"width":764,"height":1152},
		{"id":"9fe5b899a2566570","type":"text","text":"## Explanation\nDespite the unsorted array\nBinary search works in this solution works because\n- the array contains 2 sorted subarrays, \nwhen the array is rotated, \nit will be shift relative to the other \n- If the right half is sorted, the right endpoint is moved to the midpoint\n- If the left half is sorted, the left endpoint is moved to the midpoint plus one, focusing the search on the right half.\n","x":-2518,"y":1700,"width":493,"height":440},
		{"id":"7ce85dc61b902073","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":2840,"y":320,"width":550,"height":588},
		{"id":"042d6e0fdd2136de","type":"text","text":"##  [Leetcode Problem 1. Two Sum](https://leetcode.com/problems/two-sum/)\n\n```js\nvar twoSum = function(nums, target) {\n\nlet map = new Map()\n\nfor (let i = 0; i < nums.length; i++) {\n\nlet diff = target - nums[i]\n\nif (map.has(diff)) {\n\nreturn [i, map.get(diff)]\n\n}\n\nmap.set(nums[i], i)\n\n}\n\n};\n```\n\n\n\n\n","x":2000,"y":320,"width":780,"height":930},
		{"id":"8405d32b1aa494b9","type":"text","text":"## Explanation\n\nhis combined solution first trims the leading and trailing spaces from the input string. Then, it iterates through each character in the trimmed string to build each word while handling spaces. Finally, it returns the reversed string with leading and trailing spaces trimmed.\n\nThis approach effectively combines the benefits of both built-in methods and an iterative approach to solve the problem while satisfying the given conditions.","x":-240,"y":2428,"width":837,"height":302},
		{"id":"5950fe748b4b8595","type":"text","text":"## Explanation\nBoth solutions aim to reverse the order of words in the input string `s`.\n\n#### Solution 1:\n\n1. **Trim and Split**: Trim leading and trailing spaces from the input string using `trim()`, then split the string into an array of words using `split(/\\s+/)` to handle multiple spaces between words.\n2. **Reverse and Join**: Reverse the array of words using `reverse()` and join them with a single space using `join(' ')`.\n\n#### Solution 2:\n\n1. **Iterative Approach**: Iterate through each character in the input string.\n2. **Building Words**: Concatenate characters to form each word until a space is encountered.\n3. **Reversing Words**: When a space is encountered, append the current word to the beginning of the result string.\n4. **Finalization**: Trim any leading or trailing spaces from the result string before returning it.\n","x":-480,"y":1256,"width":732,"height":784},
		{"id":"a052b013ed6c1ddf","type":"text","text":"### Using both approaches\n\n\nUsing both approaches\n\n```js\n\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces from the input string\n\ns = s.trim();\n\nlet reversed = ''; // Initialize an empty string to store the reversed words\n\nlet word = ''; // Initialize an empty string to store each word\n\n// Iterate through each character in the trimmed input string\n\nfor (let i = 0; i < s.length; i++) {\n\n// If the current character is not a space, append it to the word\n\nif (s[i] !== ' ') {\n\nword += s[i];\n\n} else {\n\n// If the current character is a space and the word is not empty,\n\n// append the reversed word to the beginning of the result string\n\nif (word !== '') {\n\nreversed = word + ' ' + reversed;\n\nword = ''; // Reset the word for the next word\n\n}\n\n}\n\n}\n\n// Append the last word to the beginning of the result string\n\nreversed = word + ' ' + reversed;\n\n// Trim any leading or trailing spaces from the result string and return it\n\nreturn reversed.trim();\n\n};\n```","x":-1314,"y":2080,"width":834,"height":1077},
		{"id":"100264f276db2b90","type":"text","text":"### Optimized approach using built in functions\n```js\nvar reverseWords = function(s) {\n\n// Trim leading and trailing spaces, and split the string into an array of words\n\nconst words = s.trim().split(/\\s+/);\n\n// Reverse the array of words and join them with a single space\n\nreturn words.reverse().join(' ');\n\n};\n```","x":-2060,"y":2200,"width":700,"height":530},
		{"id":"410b42bed57268f5","type":"text","text":"##  [Leetcode 26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n```js\nfunction removeDuplicates(nums) {\n\n// Initialize the index for unique elements\n\nlet uniqueIndex = 0;\n\n  \n\n// Iterate through the array starting from the second element\n\nfor (let i = 1; i < nums.length; i++) {\n\n// Compare the current element with the previous one\n\nif (nums[i] !== nums[uniqueIndex]) {\n\n// If different, update the unique element index and copy the value\n\nuniqueIndex++;\n\nnums[uniqueIndex] = nums[i];\n\n}\n\n}\n\n  \n\n// Return the number of unique elements (length up to uniqueIndex + 1)\n\nreturn uniqueIndex + 1;\n\n}\n\n  \n\n// Test cases\n\nlet nums1 = [1, 1, 2]; // Expected output: 2\n\nconsole.log(removeDuplicates(nums1)); // Output: 2\n\nconsole.log(nums1); // Output: [1, 2, 2]\n\n  \n\nlet nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]; // Expected output: 5\n\nconsole.log(removeDuplicates(nums2)); // Output: 5\n\nconsole.log(nums2); // Output: [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] (Only the first 5 elements are important)\n```","x":470,"y":694,"width":940,"height":1220},
		{"id":"6f758c01cc58bef8","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":1450,"y":716,"width":550,"height":588},
		{"id":"fc7a69636aa78155","type":"text","text":"##  [Leetcode Problem 153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)\n\n\nBoth approaches have the same implementation because the iterative approach already achieves O(log n) time complexity. The optimized approach using binary search is essentially the same as the iterative approach.\n```js\nvar spiralOrder = function(matrix) {\n\n\tif (matrix.length === 0) \n\t\treturn [];\n\t\n\tlet result = [];\n\t\n\tlet rowBegin = 0;\n\t\n\tlet rowEnd = matrix.length - 1;\n\t\n\tlet colBegin = 0;\n\t\n\tlet colEnd = matrix[0].length - 1;\n\t\n\twhile (rowBegin <= rowEnd && colBegin <= colEnd) {\n\t\n\t\t// Traverse Right\n\t\t\n\t\tfor (let i = colBegin; i <= colEnd; i++) {\n\t\t\n\t\tresult.push(matrix[rowBegin][i]);\n\t\t\n\t\t}\n\t\t\n\t\trowBegin++;\n\t\t\n\t\t// Traverse Down\n\t\t\n\t\tfor (let i = rowBegin; i <= rowEnd; i++) {\n\t\t\n\t\tresult.push(matrix[i][colEnd]);\n\t\t\n\t\t}\n\t\t\n\t\tcolEnd--;\n\t\n\t\t// Traverse Left\n\t\t\n\t\tif (rowBegin <= rowEnd) {\n\t\t\n\t\t\tfor (let i = colEnd; i >= colBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[rowEnd][i]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\trowEnd--;\n\t\t\n\t\t// Traverse Up\n\t\t\n\t\tif (colBegin <= colEnd) {\n\t\t\n\t\t\tfor (let i = rowEnd; i >= rowBegin; i--) {\n\t\t\t\n\t\t\t\tresult.push(matrix[i][colBegin]);\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\tcolBegin++;\n\t\t\n\t}\n\t\n\treturn result;\n\n};\n```","x":-3725,"y":2297,"width":884,"height":1640},
		{"id":"5e9dc52c50f3cf06","type":"text","text":"### White Board Steps \n\n### 5 min intro\n- read/communicate problem, \n- identify conditions, \n- consider time complexity and common algorithms\n\n### 5-10 mins design the algorithm\n- use the bullets in algorithm step \n- refer to bullets as guidance in writing code/ explaining your approach\n- clarify all edge cases\n- don't rush this step.\n\n### 15-20mins write out code / test\n- include bullets on codepad screen\n- refer to documentation for shorthands if possible","x":-2793,"y":2297,"width":550,"height":588},
		{"id":"ac60ff8000caf58e","type":"text","text":"## Explanation\nDespite the unsorted array\nBinary search works in this solution works because\n- the array contains 2 sorted subarrays, \nwhen the array is rotated, \nit will be shift relative to the other \n- If the right half is sorted, the right endpoint is moved to the midpoint\n- If the left half is sorted, the left endpoint is moved to the midpoint plus one, focusing the search on the right half.\n","x":-2633,"y":2937,"width":493,"height":440}
	],
	"edges":[
		{"id":"b764c0a2d076cc12","fromNode":"e1b165f84dcc0da8","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"1274efd18c2d7c33","fromNode":"9fe5b899a2566570","fromSide":"left","toNode":"6048d7c76ce951fa","toSide":"right"},
		{"id":"85af152bfee329da","fromNode":"b1420307298e5e89","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"e716060380213b01","fromNode":"5950fe748b4b8595","fromSide":"left","toNode":"7c39023eed1dbc2b","toSide":"right"},
		{"id":"b06133d132f0e4a6","fromNode":"7c39023eed1dbc2b","fromSide":"bottom","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"49c114b25ae72f59","fromNode":"100264f276db2b90","fromSide":"top","toNode":"a052b013ed6c1ddf","toSide":"top"},
		{"id":"12f80639a3dd3627","fromNode":"8405d32b1aa494b9","fromSide":"left","toNode":"a052b013ed6c1ddf","toSide":"right"},
		{"id":"09295a9d59974d5b","fromNode":"5e9dc52c50f3cf06","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"2332491818f44863","fromNode":"ac60ff8000caf58e","fromSide":"left","toNode":"fc7a69636aa78155","toSide":"right"},
		{"id":"9eed7259372fb601","fromNode":"042d6e0fdd2136de","fromSide":"right","toNode":"7ce85dc61b902073","toSide":"top"},
		{"id":"fdd8a0dc4f72677e","fromNode":"410b42bed57268f5","fromSide":"right","toNode":"6f758c01cc58bef8","toSide":"left"},
		{"id":"12e032a602a878d0","fromNode":"61a774cdfa6f2d91","fromSide":"right","toNode":"fcf2a7234a8bfcd7","toSide":"left"},
		{"id":"7aeba7fcffb4e9fa","fromNode":"4ecde0f87437ab35","fromSide":"right","toNode":"61a774cdfa6f2d91","toSide":"left"},
		{"id":"13be519479499ec5","fromNode":"ea714bb66edcbcac","fromSide":"right","toNode":"4ecde0f87437ab35","toSide":"left"},
		{"id":"a16174c2e7b704b5","fromNode":"bbee8ab28130d7d4","fromSide":"right","toNode":"ea714bb66edcbcac","toSide":"left"},
		{"id":"90d04f3db6271cd3","fromNode":"cb309539c2d47bde","fromSide":"left","toNode":"56e4552d7cce36a6","toSide":"top"},
		{"id":"1651a26078d8db22","fromNode":"93252cdd7c373e4d","fromSide":"bottom","toNode":"cb309539c2d47bde","toSide":"left"},
		{"id":"ebf0f5d4f22b4bfd","fromNode":"56e4552d7cce36a6","fromSide":"right","toNode":"9d765ea7783a5508","toSide":"left"},
		{"id":"76f1d4d1e84ed994","fromNode":"9d765ea7783a5508","fromSide":"right","toNode":"bbee8ab28130d7d4","toSide":"left"},
		{"id":"4c87b9a41501ba96","fromNode":"ff3e76d7fb92e90b","fromSide":"right","toNode":"e1b165f84dcc0da8","toSide":"top"}
	]
}