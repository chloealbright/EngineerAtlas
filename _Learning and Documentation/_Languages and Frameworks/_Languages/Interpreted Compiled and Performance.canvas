{
	"nodes":[
		{"id":"abe316f5471c6f36","type":"text","text":"###   Compilation vs Interpretation\n#### Compiled languages\n- Faster execution speed due to the compilation step.\n- Source code translated into machine code, producing an executable file.\n- Requires a compilation step.\n- Platform-specific executables.\n\t- Example: C++\n#### Compiled Pros\n\nFaster execution speed.\n- Compilation step can catch errors early, optimizing performance.\n- Entire program optimized before running.\n- Static typing in many compiled languages catches errors early in development.\n- Executable files can be distributed independently without sharing source code.\n    - Protection of intellectual property.\n    - Commercial software distribution.\n    - Closed-source applications.\n    - Easy installation.\n    - Third-party libraries and components.\n    - Deployment on server environments.\n    - Security considerations.\n    - Vendor-locked solutions.\n\n#### Compiled Cons\nTend to have slower development cycles due to build times and compilation that allows for extensive optimizations.","x":80,"y":-300,"width":608,"height":932},
		{"id":"a753181fa2f1308f","type":"text","text":"**Compilation vs Interpretation**\n\n- **Interpreted Languages**\n    \n    - Executed line by line during runtime.\n    - Source code directly translated and executed by an interpreter.\n    - Platform independence with interpreters.\n\t    - Example: JavaScript.\n\t    - Interpreted languages like JavaScript (e.g., Node.js) require a runtime for server-side execution.\n\t    - Compiled languages like C++ don't need a runtime as they translate source code during compilation.\n\n**Interpreted Pros**\n\n- Platform independence with interpreters.\n- Portability.\n- Rapid development.\n- Ease of debugging.\n\n**Interpreted Cons**\n\n- Performance.\n- Dependency on interpreters.\n\n","x":-580,"y":-300,"width":620,"height":620},
		{"id":"fb309e9f82a342b8","type":"text","text":"### Development Speed vs Performance\n\n- interpreted languages offer faster dev cycles and compiled languages may provide better runtime performance. \n    \n### Runtime\n\n- Interpreted languages like JavaScript require a runtime like Node.js to execute the interpreted language on the server side.\n    \n- Whereas compiled languages like C++ don’t require a runtime because it already translates the source code to the executable file in the compilation stage.\n    ","x":-580,"y":367,"width":620,"height":613},
		{"id":"24dead272682f406","type":"text","text":"**Development Speed vs Performance**\n- Interpreted languages offer faster development cycles.\n- Compiled languages may provide better runtime performance.\n#### Summary\n- Depends on factors like performance requirements, development speed, and platform considerations.\n\nUpdated: March 4th 2024\nRelated: [[Languages Overview.canvas|Languages Overview]], [[Languages Overview -List View]], [[Languages VS Frameworks]], #development_speed #performance #quickread #compiled_languages #interpreted_languages","x":64,"y":674,"width":640,"height":646}
	],
	"edges":[
		{"id":"da0e42bb05655906","fromNode":"abe316f5471c6f36","fromSide":"bottom","toNode":"fb309e9f82a342b8","toSide":"bottom"}
	]
}